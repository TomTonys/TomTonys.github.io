<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python标准异常]]></title>
    <url>%2F2018%2F11%2F18%2Fpython_error_info%2F</url>
    <content type="text"><![CDATA[python标准异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageObject]]></title>
    <url>%2F2018%2F11%2F17%2FPageObject%2F</url>
    <content type="text"><![CDATA[前面我们都是基于线性模型来编写测试脚本，而且元素定位方式和属性值都是写死的。在业务场景简单的情况下这样写无可厚非，但是一旦遇到产品需求变更，业务逻辑比较复杂需要维护的时候就非常麻烦，此时就需要灵活的处理方案。 什么是PageObjectPage Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素的封装减少冗余代码，同时在后期维护中，若元素定位发生变化，只需要调整页面元素封装的代码，提高测试用例的可维护性。怎么做将各个功能的代码封装为一个类，后面要用他时，直接调用即可代码代码封装App启动配置信息(desired_caps.py)123456789101112131415161718192021222324252627282930313233343536import yamlimport logging.configfrom appium import webdriverCON_LOG = '../log/log.conf'logging.config.fileConfig(CON_LOG)logging = logging.getLogger()def appium_desired(): stream = open('../yaml/desired_caps.yaml', 'r') data = yaml.load(stream) desired_caps=&#123;&#125; desired_caps['platformName']=data['platformName'] desired_caps['platformVersion']=data['platformVersion'] desired_caps['deviceName']=data['deviceName'] desired_caps['app']=data['app'] desired_caps['noReset']=data['noReset'] desired_caps['unicodeKeyboard']=data['unicodeKeyboard'] desired_caps['resetKeyboard']=data['resetKeyboard'] desired_caps['appPackage']=data['appPackage'] desired_caps['appActivity']=data['appActivity'] logging.info('start run app...') driver = webdriver.Remote('http://'+str(data['ip'])+':'+str(data['port'])+'/wd/hub', desired_caps) driver.implicitly_wait(8) return driverif __name__ == '__main__': appium_desired() 封装基类(baseView.py)123456class BaseView(object): def __init__(self,driver): self.driver=driver def find_element(self,*loc): return self.driver.find_element(*loc) 封装通用公共类(common_fun.py)12345678910111213141516171819202122232425262728293031323334353637from appium_advance.page_object.baseView import BaseView #导入刚刚封装的基类from selenium.common.exceptions import NoSuchElementExceptionimport loggingfrom selenium.webdriver.common.by import Byfrom appium_advance.page_object.desired_caps import appium_desired #导入刚刚封装的app启动信息class Common(BaseView): #继承基类 cancelBtn=(By.ID,'android:id/button2') #将元素查找剃出来变为可变参数，方便后期维护 skipBtn=(By.ID,'com.tal.kaoyan:id/tv_skip') def check_cancelBtn(self): logging.info("============check_cancelBtn===============") try: element = self.driver.find_element(*self.cancelBtn) except NoSuchElementException: logging.info('update element is not found!') else: logging.info('click cancelBtn') element.click() def check_skipBtn(self): logging.info("==========check_skipBtn===========") try: element = self.driver.find_element(*self.skipBtn) except NoSuchElementException: logging.info('skipBtn element is not found!') else: logging.info('click skipBtn') element.click()if __name__ == '__main__': driver=appium_desired() com=Common(driver) com.check_updateBtn() com.check_skipBtn() 封装登录操作(loginView.py)1234567891011121314151617181920212223242526272829import loggingfrom appium_advance.page_object.common_fun import Common #导入刚刚封装的通用公共类from appium_advance.page_object.desired_caps import appium_desiredfrom selenium.webdriver.common.by import Byclass LoginView(Common): #继承common-&gt;BaseView username_type=(By.ID,'com.tal.kaoyan:id/login_email_edittext') #将元素查找剃出来变为可变参数，方便后期维护 password_type=(By.ID,'com.tal.kaoyan:id/login_password_edittext') loginBtn=(By.ID,'com.tal.kaoyan:id/login_login_btn') def login_action(self,username,password): self.check_cancelBtn() #调用继承的common的check_cancelBtn()方法 self.check_skipBtn() #调用继承的common的check_skipBtn()方法 logging.info('===============login===============') logging.info('input username:%s'%username) self.driver.find_element(*self.username_type).send_keys(username) logging.info('input password:%s'%password) self.driver.find_element(*self.password_type).send_keys(password) logging.info('click loginBtn.') self.driver.find_element(*self.loginBtn).click() logging.info('login finished ')if __name__ == '__main__': driver=appium_desired() l=LoginView(driver) l.login_action('name123','pwd123') unittest用例封装封装用例启动结束时的配置(myunit.py)123456789101112131415import unittestfrom appium_advance.page_object.desired_caps import appium_desired #导入刚刚封装的app启动信息import loggingfrom time import sleepclass StartEnd(unittest.TestCase): def setUp(self): logging.info('======setUp=========') self.driver=appium_desired() def tearDown(self): logging.info('======tearDown=====') sleep(5) self.driver.close_app() 测试用例封装(test_login.py)1234567891011121314151617181920212223242526from appium_advance.unittest.myunit import StartEndfrom appium_advance.page_object.loginView import LoginViewimport unittestimport loggingclass TestLogin(StartEnd): def test_login_zxw2018(self): logging.info('=========test_login_zxw2018============') l=LoginView(self.driver) l.login_action('name2018','pwd2018') def test_login_zxw2017(self): logging.info('==========test_login_zxw2017========') l=LoginView(self.driver) l.login_action('name2017','pwd2017') def test_login_error(self): logging.info('=======test_login_error=========') l=LoginView(self.driver) l.login_action('666','222')if __name__ == '__main__': unittest.main() _1.注意test开头 2.运行顺序一个test_xxx-&gt;setUp-&gt;tearDown-&gt;另一个test_xxx-&gt;…，test_xxx的顺序为xxx的默认排序，并非像线性一样从上到下的运行。_ 逻辑图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>Python</tag>
        <tag>PageObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取LOL所有英雄技能信息]]></title>
    <url>%2F2018%2F11%2F15%2Fpython_get_lolhero%2F</url>
    <content type="text"><![CDATA[工欲善其事 必先利其器要想玩好LOL，那了解所有英雄的技能必然是其最基本的。所以此爬虫就应运而生 运行环境 python 3.7 此爬虫所用的库有 requests (获取网页信息) openpyxl (Excel相关操作) pymysql (MySQL数据库相关操作) re (正则) 代码下面有已打包为EXE的程序，可直接使用 主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import requestsimport reimport openpyxlimport pymysqldef get_html(hero): headers = &#123; 'Referer': 'http://lol.qq.com/web201310/info-defail.shtml?id=' + hero, 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36', &#125; url = 'http://lol.qq.com/biz/hero/' + hero + '.js' # print(url) response = requests.get(url, headers=headers) response = response.text return responsedef hero_info(response): # 英雄名称 hero_name = re.findall(r'"name":"(.*?)","title"', response, re.S)[0] hero_title = re.findall(r'"title":"(.*?)","tags"', response, re.S)[0] # 技能(QWER) hero_spells = re.findall(r'"spells":(.*?),"passive"', response, re.S)[0] # 技能名称 hero_spells_name = re.findall( r'"name":"(.*?)","description"', hero_spells, re.S) # 技能描述 hero_spells_description = re.findall( r'"description":"(.*?)","image"', hero_spells, re.S) # 技能消耗 hero_spells_resource = re.findall( r'"resource":"(.*?)"&#125;', hero_spells, re.S) # 技能主被动 hero_spells_group = re.findall(r'"group":"(.*?)","x"', hero_spells, re.S) spells_Q = hero_spells_name[0] + ':' + hero_spells_description[0] + \ '|' + hero_spells_resource[0] + '|' + hero_spells_group[0] spells_W = hero_spells_name[1] + ':' + hero_spells_description[1] + \ '|' + hero_spells_resource[1] + '|' + hero_spells_group[1] spells_E = hero_spells_name[2] + ':' + hero_spells_description[2] + \ '|' + hero_spells_resource[2] + '|' + hero_spells_group[2] spells_R = hero_spells_name[3] + ':' + hero_spells_description[3] + \ '|' + hero_spells_resource[3] + '|' + hero_spells_group[3] Spells = spells_Q + '\n' + spells_W + '\n' + spells_E + '\n' + spells_R # 被动技能 hero_passive = re.findall(r'"passive":(.*?),"lore"', response, re.S)[0] # 被动技能名称 hero_passive_name = re.findall( r'"name":"(.*?)","description"', hero_passive, re.S)[0] # 技能描述 hero_passive_description = re.findall( r'"description":"(.*?)","image"', hero_passive, re.S)[0] # 技能主被动 hero_passive_group = re.findall( r'"group":"(.*?)","x"', hero_passive, re.S)[0] passive = hero_passive_name + ':' + \ hero_passive_description + '|' + hero_passive_group hero_spells_info = [hero_name, hero_title, passive, Spells] return hero_spells_infodef get_hero(): with open('hero', 'r') as f: hero = f.readlines() return herodef save_to_excel(her): wb = openpyxl.Workbook() ws = wb.active ws['A1'] = '英雄称号' ws['B1'] = '英雄名称' ws['C1'] = '被动技能' ws['D1'] = '主动技能' for hero in her: ws.append(hero) wb.save('herotest.xlsx')def save_to_mysql(her): for i in her: ch = '"' + i[0] + '"' name = '"' + i[1] + '"' bd_name = '"' + i[2] + '"' zd_name = '"' + i[3] + '"' db = pymysql.connect(host='localhost', user='root', password='123456', database='python_mysql', charset='utf8') cursor = db.cursor() sql = ''' insert into lolheroinfo values (%s, %s, %s, %s); ''' % (ch, name, bd_name, zd_name) # print(sql) try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit() print(ch, ' insert into success!') except: db.rollback() db.close() return Truedef main(): heros = get_hero() her = [] for hero in heros: hero = hero.split('"')[3] response = get_html(hero) her_infos = hero_info(response) her_encode = [] for i in her_infos: i = i.encode("latin-1").decode("unicode_escape") her_encode.append(i) her.append(her_encode) save_to_excel(her) #save_to_mysql(her)if __name__ == '__main__': main() 获取英雄数据文件运行此文件后会在当前目录下生产hero的数据文件123456789101112131415161718import requestsimport reheaders = &#123; 'Referer': 'https://lol.qq.com/data/info-defail.shtml?id=Aatrox', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',&#125;response = requests.get('https://lol.qq.com/biz/hero/champion.js', headers=headers)keys = re.findall(r'"keys":&#123;(.*?)&#125;,"data"',response.text,re.S)keys = keys[0]keys = keys.split(',')with open('hero','w') as f: for key in keys: f.write(key) f.write('\n') print(key) _如果想要保存到MySQL，请先创建MySQL数据库，然后用下面的代码创建表，最后取消主代码save_to_mysql(her)的注释即可_ 创建数据表代码1234567891011121314151617181920212223242526#!/usr/bin/python3 import pymysql # 打开数据库连接db = pymysql.connect("localhost","root","123456","python_mysql" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute("DROP TABLE IF EXISTS EMPLOYEE") # 使用预处理语句创建表sql = """CREATE TABLE lolheroinfo ( 英雄称号 CHAR(255), 英雄名称 CHAR(255), 被动技能 CHAR(255), 主动技能 varchar(999) ) """ cursor.execute(sql) # 关闭数据库连接db.close() Excel版：MySQL版：下面是上文代码打包为EXE版(pyinstaller)主文件(Excel版)：https://www.lanzous.com/i2dnmvg主文件(MySQL版)：https://www.lanzous.com/i2dnmej数据文件：https://www.lanzous.com/i2dnn9a获取数据文件：https://www.lanzous.com/i2dnm7c 最后温馨提示请合理使用爬虫]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LOL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[faces]]></title>
    <url>%2F2018%2F11%2F11%2Ffaces%2F</url>
    <content type="text"><![CDATA[faces人脸识别能用来进行人脸识别的库有很多，而本篇文章介绍利用Python+OpenCV来进行人脸识别，包括图片的人脸以及摄像头实时人脸。 OpenCV简单介绍OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。支持C、C++、Python、Java等。下载OpenCV库pip install opencv-pythonPython 2.7是2.x系列中唯一受支持的版本。Python 3.x版本遵循Numpy版本。目前支持的Python版本有2.7、3.4~3.7。 利用OpenCV读取图片并显示12345import cv2 as cvimg=cv.imread("404.png")cv.imshow("pic",img)cv.waitKey(0)cv.destroyAllWindows() 利用OpenCV获取PC摄像头并显示12345678910111213import cv2import numpyimport matplotlib.pyplot as plot# 摄像头对象cap = cv2.VideoCapture(0)while(True): ret, frame = cap.read() # 读取一帧的图像 cv2.namedWindow("camera", 0) # 0使其可以任意拖动窗口大小 cv2.imshow("camera", frame) # 显示图像 if(cv2.waitKey(1) &amp; 0xFF == ord('q')): #设置按q退出 breakcap.release() #释放摄像头cv2.destroyAllWindows() 利用OpenCV读取图片并识别人脸1234567891011121314151617181920212223242526272829303132333435363738394041import cv2# 待检测的图片路径imagepath="3.jpg"while(True): image = cv2.imread(imagepath) gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) ''' # 获取人脸识别训练数据 对于人脸特征的一些描述，opencv在读取完数据后很据训练中的样品数据， 就可以感知读取到的图片上的特征，进而对图片进行人脸识别。 xml数据下载， 参考：https://github.com/opencv/opencv/tree/master/data/haarcascades ''' face_cascade = cv2.CascadeClassifier(r'./haarcascade_frontalface_default.xml') # 探测人脸 # 根据训练的数据来对新图片进行识别的过程。 faces = face_cascade.detectMultiScale( gray, scaleFactor = 1.15, minNeighbors = 3, minSize = (5,5), #flags = cv2.HAAR_SCALE_IMAGE ) # 我们可以随意的指定里面参数的值，来达到不同精度下的识别。返回值就是opencv对图片的探测结果的体现。 # 处理人脸探测的结果 #print ("发现&#123;0&#125;个人脸!".format(len(faces))) for(x,y,w,h) in faces: cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2) # 用矩形圈出人脸 # cv2.circle(image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2) #用圆形圈出人脸 cv2.imshow("image | &#123;0&#125; faces were found!".format(len(faces)),image) if(cv2.waitKey(1) &amp; 0xFF == ord('q')): breakcv2.waitKey(0)cv2.destroyAllWindows() 利用OpenCV获取PC摄像头实时识别人脸并显示12345678910111213141516171819import cv2cap = cv2.VideoCapture(0) # 使用第0个摄像头face_cascade = cv2.CascadeClassifier(r'./haarcascade_frontalface_default.xml') # 加载人脸特征库while(True): ret, frame = cap.read() # 读取一帧的图像 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 转灰 faces = face_cascade.detectMultiScale(gray, scaleFactor = 1.15, minNeighbors = 5, minSize = (5, 5)) # 检测人脸 for(x, y, w, h) in faces: cv2.rectangle(gray, (x, y), (x + w, y + h), (0, 255, 0), 2) # 用矩形圈出人脸 cv2.imshow('Face Recognition', gray) if cv2.waitKey(1) &amp; 0xFF == ord('q'): breakcap.release() # 释放摄像头cv2.destroyAllWindows() 可以不用转灰，但环境复杂时，识别率会降低]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>faces</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志收集-logging]]></title>
    <url>%2F2018%2F10%2F31%2Flogging%2F</url>
    <content type="text"><![CDATA[logging日志作用不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。 日志级别CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUGDEBUG：调试信息，也是最详细的日志信息INFO：证明事情按预期工作WARNING：表面发生了一些意外，或者不久的将来会发生问题(如:磁盘满了)。软件还是在正常工作ERROR：由于更严重的问题，软件已经不能执行一些功能了CRITICAL:严重错误，表面软件已经不能继续运行了日志格式一般为时间+模块+行数+日志具体信息的内容格式 日志位置一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。logging用法logging模块官方文档 basicConfig(**kwargs) 为日志记录系统做基本配置部分参数 filename 指定日志文件名称 filemode 指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a） format 为处理程序使用指定的格式字符串。 level 将根记录器级别设置为指定级别。(仅会显示指定级别以及比它更严重的级别。如level=logging.ERROR，则仅会显示ERROR和CRITICAL级别的日志)事例用法1234567891011import logginglogging.basicConfig(level=logging.DEBUG, filename='runlog.log', format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', filemode='a')logging.debug('debug info')logging.info('info inof')logging.warning('warning info')logging.error('error info')logging.critical('critical info') 实例:将之前yaml的代码加上logging1234567891011121314151617181920212223242526import yamlfrom appium import webdriverimport loggingwith open('device_info.yaml', 'r', encoding='utf-8') as file: data = yaml.load(file)desired_caps = &#123;&#125;desired_caps['platformName'] = data['platformName']desired_caps['platforVersion'] = data['platforVersion']desired_caps['deviceName'] = data['deviceName']desired_caps['app'] = data['app']desired_caps['appPackage'] = data['appPackage']desired_caps['appActivity'] = data['appActivity']desired_caps['noReset'] = data['noReset']logging.basicConfig(level=logging.INFO, filename='runlog.log', format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', filemode='a')logging.info('start app...')driver = webdriver.Remote( 'http://' + str(data['ip']) + ':' + str(data['port']) + '/wd/hub', desired_caps)logging.info('Skip startup page...')driver.find_element_by_id('com.baidu.BaiduMap:id/dj2').click()logging.info('Close Xiaodu...')driver.find_element_by_id('com.baidu.BaiduMap:id/byo').click()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>logging</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml]]></title>
    <url>%2F2018%2F10%2F26%2Fyaml%2F</url>
    <content type="text"><![CDATA[yaml当一个Python用例写完了后，要更改数据时(如换一台设备），就需要去改Python代码，但改Python代码就容易将其他代码改错。所以这里就将常用数据用yaml来存储，需要更改时直接更改yaml文件就行了。 yaml介绍YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。(来自维基百科)yaml基本用法 123platformName: AndroidplatforVersion: 5.1.1... yaml注意事项1. 冒号(:)后要空一格2. yaml不支持tab缩进，支持空格缩进，将同级对齐就好 12345name: Tom Smithage: 37spouse: name: Jane Smith age: 27 3. 在yaml里，用#做注释Python读取yamlPython读取yaml的数据时，需要导入yaml，读取时用yaml.load()读取，具体代码如下： yaml文件 123456789platformName: AndroidplatforVersion: 5.1.1deviceName: 127.0.0.1:62026app: H:\TestLearning\com.baidu.BaiduMap.apkappPackage: com.baidu.BaiduMapappActivity: com.baidu.baidumaps.WelcomeScreennoReset: Falseip: 127.0.0.1port: 4723 Python读取 123456789101112131415import yamlfrom appium import webdriverwith open('device_info.yaml', 'r', encoding='utf-8') as file: data = yaml.load(file)desired_caps = &#123;&#125;desired_caps['platformName'] = data['platformName']desired_caps['platforVersion'] = data['platforVersion']desired_caps['deviceName'] = data['deviceName']desired_caps['app'] = data['app']desired_caps['appPackage'] = data['appPackage']desired_caps['appActivity'] = data['appActivity']desired_caps['noReset'] = data['noReset']driver = webdriver.Remote('http://' + str(data['ip']) + ':' + str(data['port']) + '/wd/hub', desired_caps)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python将图片转化ASCII]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E5%B0%86%E5%9B%BE%E5%83%8F%E8%BD%AC%E5%8C%96%E4%B8%BAasci%2F</url>
    <content type="text"><![CDATA[用Python将图片转化ASCII思路将彩图转化为灰度模式(去掉颜色)，再更具每个像素的灰度值找到不同复杂度的ASCII字符一一映射，从而转换为ASCII字符图像 环境(我的环境) 1. python3.72. Pillow库注意:Pillow库与PIL库不可存在于同一环境3. 图片 实现步骤 1. 导入Pillow库 from PIL import Image 2. 读取图片并将其转换为灰度模式(去色) 123img = Image.open("tomtony.png")img_gray = img.convert("L")img_gray.show() 3. 重置图片大小 img_gray = img_gray.resize((int(img_gray[0] * 0.5), int(img_gray[1] * 0.5)))0.5为缩放大小可随意修改 4. 根据灰度值转化为ASCII 灰度模式的图像它每个像素有一个灰度值，这个值的范围是 0 ~ 255，它的值越小说明它越黑(0是纯黑色，255是纯白色) 获取灰度值 img_gray.getpixel(100, 100)图像在100*100这个像素的灰度值 根据灰度值将图像转化为asci 1234567asciis = "@%#*+=-:. "texts = ''for row in range(height): for col in range(width): gray = img_gray.getpixel((col, row)) texts += asciis[int(gray / 255 * 9)] # 根据灰度值选择不同复杂度的 ASCII 字符 texts += '\n' 5. 最后保存为文件12with open("ascii.txt", "w") as f: f.write(texts) 最终代码12345678910111213141516171819202122232425262728293031323334353637from PIL import Imagedef get_pic_info(pic, zoom_pic): img = Image.open(pic) img_gray = img.convert('L') width, height = img_gray.size img_gray = img_gray.resize((int(width * zoom_pic), int((height * zoom_pic) * 0.5))) size = img_gray.size return size, img_graydef get_ascils(pic_info): width = pic_info[0][0] height = pic_info[0][1] img_gray = pic_info[1] ascils = '@%#*+=_. ' texts = "" for row in range(height): for col in range(width): gray = img_gray.getpixel((col, row)) texts += ascils[int(gray / 255 * 8)] texts += '\n' return textsdef save_ascil(pic_to_ascils, pic): name = ''.join(pic.split('.')[:-1]) + str('.txt') with open(name, 'w') as file: file.write(pic_to_ascils)def main(): pic = input('请放入图片:') zoom_pic = float(input('请输入缩放比例(eg:0.1):')) pic_info = get_pic_info(pic, zoom_pic) pic_to_ascils = get_ascils(pic_info) save_ascil(pic_to_ascils, pic)if __name__ == '__main__': main() 此篇blog是学习了小甲鱼的极客Python之效率革命的将你的女神变成字符画之后写的学习笔记]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多点触控 MultiAction]]></title>
    <url>%2F2018%2F10%2F21%2FMultiAction%2F</url>
    <content type="text"><![CDATA[MultiActionMultiAction是多点触控的类，可以模拟用户多点操作。主要包含add()和perform()两个方法，MultiAction可以结合前面所学的ActionTouch可以模拟出用户的多个手指滑动的效果。 12from appium.webdriver.common.multi_action import MultiActionfrom appium.webdriver.common.touch_action import TouchAction 加载:方法add(self,*touch_actions)将TouchAction对象添加到MultiAction中，稍后执行参数:touch_action 一个后多个TouchAction对象，描述一个手指要执行的动作链用法: 12345a1 = TouchAction(driver)a1.press(x,y).move_to(x,y).release()a2 = TouchAction(driver)a2.press(x,y).move_to(x,y).release()MultiAction(driver).add(a1, a2) 执行perform(self) 执行存储在对象中的操作。用法: 12345a1 = TouchAction(driver)a1.press(x,y).move_to(x,y).release()a2 = TouchAction(driver)a2.press(x,y).move_to(x,y).release()MultiAction(driver).add(a1, a2).perform() 手机缩放图示理解 实例在百度APP中执行放大两次再缩小两次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from appium import webdriverfrom appium.webdriver.common.multi_action import MultiActionfrom appium.webdriver.common.touch_action import TouchActiondesired_caps = &#123;&#125;desired_caps['platformName']='Android'desired_caps['deviceName']='127.0.0.1:62026'desired_caps['platforVersion']='5.1.1'desired_caps['app']=r'H:\测试学习\com.baidu.BaiduMap.apk'desired_caps['appPackage']='com.baidu.BaiduMap'desired_caps['appActivity']='com.baidu.baidumaps.WelcomeScreen'desired_caps['noReset']='False'driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)driver.implicitly_wait(10)driver.find_element_by_id('com.baidu.BaiduMap:id/dj2').click()driver.find_element_by_id('com.baidu.BaiduMap:id/byo').click()def get_size(): x = driver.get_window_size()['width'] y = driver.get_window_size()['height'] return x, ydef pinch(): size = get_size() x = size[0] y = size[1] action1 = TouchAction(driver) action2 = TouchAction(driver) pinch_action = MultiAction(driver) action1.press(x = x * 0.2, y = y * 0.2).wait(1000).move_to(x = x * 0.4, y = y*0.4).wait(1000).release() action2.press(x = x * 0.8, y = y * 0.8).wait(1000).move_to(x = x * 0.6, y = y*0.6).wait(1000).release() print('pinch...') pinch_action.add(action1, action2) pinch_action.perform()def zoom(): size = get_size() x = size[0] y = size[1] action1 = TouchAction(driver) action2 = TouchAction(driver) zoom_action = MultiAction(driver) action1.press(x=x * 0.4, y=y * 0.4).wait(1000).move_to(x=x * 0.2, y=y * 0.2).wait(1000).release() action2.press(x=x * 0.6, y=y * 0.6).wait(1000).move_to(x=x * 0.8, y=y * 0.8).wait(1000).release() print('zoom...') zoom_action.add(action1, action2) zoom_action.perform()if __name__ == '__main__': for i in range(2): pinch() for i in range(2): zoom()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>触控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性测试简单介绍]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。而对于浏览器软件的开发和设计，浏览器对标准的更好兼容能够给用户更好的使用体验。 --来自百度百科 什么情况下做兼容性测试用的比较少的页面(比如后台)是不需要兼容性测试的，只有大量用户用的B/S网页才需要做兼容性测试一般用什么浏览器一般必须的有：360 IE Firefox Chroem Safari，其他看公司具体要求浏览器版本一般用最新或自己电脑上的版本就可以了检查内容主要检查：功能、UI辅助工具1. https://app.crossbrowsertesting.com, 国外的一个兼容性测试网站，可以模拟主流平台和浏览器，有试用时间 2. Turbo 官网：https://turbo.net/browsers, 是一个浏览器沙盒，内置有主流的浏览器，就不用在自己的电脑上安装各种浏览器。(缺点：程序启动速度慢)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bug的等级]]></title>
    <url>%2F2018%2F10%2F18%2Fbug%E7%AD%89%E7%BA%A7%E5%88%86%E5%88%92%2F</url>
    <content type="text"><![CDATA[Bug的等级bug的等级，这个划分有分三级、四级和五级的。如果是等级越高，那么可能被修复的等级也会高一些，在一些公司bug的数量和bug的等级是考察绩效的重要标准。很多情况下，我们提交的bug大致的等级差不多即可，没有严格区分。bug的等级，一般可参照如下判断 Bug划分依据（参考）（一）致命错误： 1、常规操作引起的系统崩溃、死机、死循环。（如：输入正确的用户名密码后点击登录，机器会卡死） 2、造成数据泄漏的安全性问题。（如：恶意攻击造成的账户私密信息泄漏） 3、涉及金钱 计算（二）严重错误： 1、重要功能不能实现 2、错误的波及面广，影响到其他重要功能正常实现 3、非常规操作导致的程序崩溃、死机、死循环 4、外观难以接受的缺陷 5、密码明文显示（三）一般错误：不影响产品的运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷 1、次要功能不能实现 2、操作界面错误（包括数据窗口内列明定义、含义不一致） 3、查询错误，数据错误显示 4、简单的输入限制未放在前段进行控制（格式限制） 5、删除操作为给出提示Bug的生命周期]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>等级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例]]></title>
    <url>%2F2018%2F10%2F17%2FTestCase%2F</url>
    <content type="text"><![CDATA[测试用例测试用例的八大要素：1.用例编号产品名-测试阶段-测试项-xxx 2.测试项目对应一个功能模块(细分功能) 3.测试标题直接对测试点进行细化得出，输入内容+结果，同一功能模块标题不能重复(来自测试点) 4.重要级别高/中/低 5.预置条件需满足一些前提条件，否则用例无法执行 6.测试输入需要加工的输入信息，更具具体情况来设计(跟步骤结合起来一定要有指导意义) 7.操作步骤明确给出每个步骤的描述，执行人员可以根据该步骤完成执行工作 8.预期结果根据预期输出对比实际结果，来判断被测对象是否符合需求。(预期结果唯一，不能出现”是否或者”) 实例Excel版XMind版]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>用例设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例设计方法]]></title>
    <url>%2F2018%2F10%2F17%2FTestCaseDesignMethod%2F</url>
    <content type="text"><![CDATA[测试用例设计方法 等价类划分法等价类划分法时一种典型的、重要的黑盒测试方法，是指某个输入域的子集合。在该子集合中，所有的输入数据对于揭露软件中的储物都是等效的。等价类划分有效等价类和无效等价类 例子 边界值分析法边界值分析法时对等价类划分法的一个补充，边界值一般都是从等价的边缘值去寻找。边界值分析法的基本思想：正好等于、刚刚大于、刚刚小于边界的值作为初始数据注意：0和负数是特殊值，考虑边界值是也要考虑进入 例子在上图的条件下边界值有-1,0,1,58,59,60,61,99,100,101 错误推测法故意进行错误操作，看看有没有异常处理 例子例如测试登录功能时，用错误的账号密码进行测试 场景法从用户的角度出发，看用户怎么操作(一般用于多个功能) 例子]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>用例设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动操作 TouchAction]]></title>
    <url>%2F2018%2F10%2F16%2FTouchAction%2F</url>
    <content type="text"><![CDATA[TouchActionTouch Action包含一些列操作，比如按压、长按、点击、移动、暂停。由着些不同操作可以组成一套动作。使用TochAction需要先导入对应的模块from appium.webdriver.common.touch_action import TouchAction 按压方法：press() 开始按压一个元素或坐标点（x,y）。通过手指按压手机屏幕的某个位置。 press也可以接收屏幕的坐标（x,y）。 12press(self, el=None, x=None, y=None)TouchAction(driver).press(x=0,y=300) 长按方法：longPress() 开始按压一个元素或坐标点（x,y）。 相比press()方法，longPress()多了一个入参，既然长按，得有按的时间吧。duration以毫秒为单位。1000表示按一秒钟。其用法与press()方法相同。 long_press(self, el=None, x=None, y=None, duration=1000) 点击方法：tap() 对一个元素或控件执行点击操作。用法参考press()。 tap(self, element=None, x=None, y=None, count=1) 移动_方法：move_to() 将指针从上一个点移动到指定的元素或点。_ move_to(self, el=None, x=None, y=None) 暂停方法：Wait(),暂停脚本的执行，单位为毫秒 wait(self, ms=0) 释放方法release() 结束的行动取消屏幕上的指针。 release(self) 执行perform() 执行的操作发送到服务器的命令操作 perform(self) TouchAction实例-九宫格滑动操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from appium import webdriverfrom appium.webdriver.common.touch_action import TouchActionfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.common.exceptions import NoSuchElementExceptionfrom time import sleepdesired_caps=&#123;&#125;desired_caps['platformName']='Android'desired_caps['deviceName']='127.0.0.1:62025'desired_caps['platforVersion']='5.1.1'desired_caps['app']=r'H:\测试学习\mymoney.apk'desired_caps['appPackage']='com.mymoney'desired_caps['appActivity']='com.mymoney.biz.splash.SplashScreenActivity'driver=webdriver.Remote('http://localhost:4723/wd/hub',desired_caps)driver.implicitly_wait(5)def get_size(): x=driver.get_window_size()['width'] y=driver.get_window_size()['height'] return x,ydef swipeLeft(): l=get_size() x1=int(l[0]*0.9) y1=int(l[1]*0.5) x2=int(l[0]*0.1) driver.swipe(x1,y1,x2,y1,1000)def swipeUp(): l = get_size() x1 = int(l[0] * 0.5) y1 = int(l[1] * 0.95) y2 = int(l[1] * 0.35) driver.swipe(x1, y1, x1, y2, 1000)WebDriverWait(driver,6).until(lambda x:x.find_element_by_id('com.mymoney:id/next_btn'))for i in range(2): swipeLeft() sleep(0.5)driver.find_element_by_id('com.mymoney:id/begin_btn').click()try: closeBtn=driver.find_element_by_id('com.mymoney:id/close_iv')except NoSuchElementException: passelse: closeBtn.click()driver.find_element_by_id('com.mymoney:id/nav_setting_btn').click()WebDriverWait(driver,6).until(lambda x:x.find_element_by_id('com.mymoney:id/content_container_ly'))swipeUp()driver.find_element_by_android_uiautomator('new UiSelector().text("高级")').click()driver.find_element_by_id('com.mymoney:id/password_protected_briv').click()driver.find_element_by_id('com.mymoney:id/lock_pattern_or_not_sriv').click()for i in range(2): TouchAction(driver).press(x=218,y=298).wait(2000)\ .move_to(x=360,y=298).wait(1000)\ .move_to(x=510,y=440).wait(1000)\ .move_to(x=510,y=590).wait(1000)\ .release().perform()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>touchaction</tag>
        <tag>滑动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动]]></title>
    <url>%2F2018%2F10%2F14%2Fswipe%2F</url>
    <content type="text"><![CDATA[swipe 滑动语法 driver.swipe(x1, y1, x2, y2, 1000) 由坐标(x1,y1)滑动到坐标(x2,y2)处,持续时间1秒 坐标获取技巧_可同过get_devices_size()得到荧幕宽高后,在分别乘以一个0.X的浮点数则可得到一坐标_ 1234x = driver.get_window_size()['width']y = driver.get_window_size()['height']x1 = int(x*0.9)y1 = int(y*0.5) 具体事例由右向左滑动两次 123456789101112131415161718from appium_test.capability import driverimport timedef get_devices_size(): x = driver.get_window_size()['width'] y = driver.get_window_size()['height'] return x, ydef swipeLeft(): l = get_devices_size() x1 = int(l[0]*0.9) x2 = int(l[0]*0.1) y1 = int(l[1]*0.5) driver.swipe(x1, y1, x2, y1, 1000)for i in range(2): swipeLeft() time.sleep(0.5)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>swipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5定位方法]]></title>
    <url>%2F2018%2F10%2F14%2FH5%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[APP内嵌H5定位方法方法：定位app内元素时用appium定位方法定位,定位H5页面元素时用selenium定位方法定位.他们之间的切换用contexts切换 第一步 得到APP和H5的contexts值 12contexts = driver.contextsprint(contexts) 这里得到的第一个值为APP的contexts，第二个为selenium的contexts so 12context_appium = contexts[0]context_selenium = context[1] 第二步 appium和selenium之间的切换appium切换到selenium driver.switch_to.contexts(&#39;WEBVIEW_com.wondershare.drfone&#39;)或 driver.switch_to.contexts(context_selenium) selenium切换到appium driver.switch_to.context(&#39;NATIVE_APP&#39;)或 driver.switch_to.contexts(context_appium) 实例 1234567891011121314151617181920212223242526272829303132333435from appium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitimport timedesired_caps=&#123;&#125;desired_caps['platformName']='Android'desired_caps['platformVersion']='5.1.1'desired_caps['deviceName']='127.0.0.1:21503'desired_caps['app']=r'H:\测试学习\dr.fone3.2.0.apk'desired_caps['appPackage']='com.wondershare.drfone'desired_caps['appActivity']='com.wondershare.drfone.ui.activity.WelcomeActivity'driver=webdriver.Remote('http://localhost:4723/wd/hub',desired_caps)driver.implicitly_wait(8)time.sleep(5)driver.find_element_by_id('com.wondershare.drfone:id/btnBackup').click()WebDriverWait(driver,10).until(lambda x:x.find_element_by_id('com.wondershare.drfone:id/btnRecoverData'))driver.find_element_by_id('com.wondershare.drfone:id/btnRecoverData').click()WebDriverWait(driver,10).until(lambda x:x.find_element_by_class_name('android.webkit.WebView'))contexts=driver.contextsprint(contexts)context_selenium = contexts[1]context_appium = contexts[0]#driver.switch_to.context(context_selenium)driver.switch_to.context('WEBVIEW_com.wondershare.drfone')driver.find_element_by_id('email').send_keys('shuqing2018@163.com')driver.find_element_by_class_name('btn_send').click()#driver.switch_to.context(context_appium)driver.switch_to.context('NATIVE_APP')driver.find_element_by_class_name('android.widget.ImageButton').click()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>h5定位</tag>
        <tag>contexts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux计划任务_crontab]]></title>
    <url>%2F2018%2F10%2F13%2FLinux%E8%AE%A1%E5%88%92_crontab%2F</url>
    <content type="text"><![CDATA[crontab常用命令创建计划任务 crontab -e 查看已创建的计划任务 crontab -l 删除计划任务 crontab -r 计划格式 * * * * * command 分 时 日 月 周 命令星号（）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如/10，如果用在minute字段，表示每十分钟执行一次。 例子 0 12,17,20 * * * python2 /home/test/test.py &gt;&gt; /home/test/test.log 每天12/17/20点整执行Python文件test.py,并将输出结果保存到test.log文件中]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ADB截图 adb shell screencap /sdcard/wangdoujia.png 安装apk adb install xxx.apk 删除APP adb uninstall xxxxxx为apk的包名 显示手机所有的APP包名 adb shell pm list package aapt查看app的package aapt dump badging H:\测试学习\wandoujia.apk | findstr “package” 查看app的启动页面的activity aapt dump badging H:\测试学习\wandoujia.apk | findstr “launchable-activity” Moneky在手机上执行100个伪随机事件 adb shell monkey 100 每次随机事件间隔3秒并显示日志 adb shell monkey -v –throttle 3000 10 自定义事件概率touch概率为30% adb shell monkey -v –pct-touch 30 200_触控touch,启动事件—appswtich,手势—motion,旋转—rotation,轨迹—trackball,基本导航—nav,主要导航-majornav,系统按键-syskeys 设定多个事件的概率 adb shell monkey -v –pct-touch 30 –pct-motion 40 200 在指定的地方执行事件在指定的app里进行随机事件 adb shell monkey -p 包名 100 在指定的activity内进行随机事件 adb shell monkey -c activity 100 遇到特殊事件处理遇到crash后继续事件 adb shell monkey –ignore-crashes 遇到超时时继续事件 adb shell monkey –ignore-timouts 遇到权限不足时继续事件 adb shell monkey –ignore-security-exceptions Moneky API启动应用的activity LaunchActivity(pkg_name,cl_name)参数：包名，启动的activity 模拟一次点击事件 Tap(x,y,tapDuration)参数：x,y坐标。tap持续时间(省) 设置睡眠时间 UserWait(sleepTime) 按键 DispatchPress(keyName) 输入字符串 DispatchString(input) 打开关闭软键盘 DispatchFlip(true/false) 长按事件 PressAndHold(x,y,pressDuration) 缩放手势 Drag(xStart,yStart,xend,yend,x2Start,y2Start,x2end,y2end,stepCount) 运行1次脚本 adb shell monkey -f /sdcard/test.txt -v -v 1脚本是用Moneky API编写的脚本,文件后缀理论不限一般为.txt,脚本需放在测试手机内 log保存 adb shell monkey 100 1&gt;d:\log.log 2&gt;d:\error.log1标准流在log.log 文件中,2错误流在error.log中 实例 adb shell monkey -p com.tal.kaoyan –pct-touch 40 –pct-motion 25 –pct-appswitch 10 –pct-rotation 5 -s 1666 –throttle 400 –ignore-crashes –ignore-timeouts -v -v 200在考研APP里以触控25%手势40%启动10%旋转5%的概率和seed为1666为条件执行200次随机事件，并且每个事件隔0.4秒执行一次，在执行中遇到crash和权限问题都跳过继续执行之后的事件]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>adb</tag>
        <tag>aapt</tag>
        <tag>Moneky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架设简单的服务器]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%9E%B6%E8%AE%BE%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在虚拟机中的Centos 7上架设搭建简单的网站1. 安装Apache服务 1yum install -y httpd 2. 启动Apache服务 1systemctl start httpd.service 3. 在“/var/www/”下创建web文件夹 1mkdir /var/www/tony 4. 更改配置文件，设置基于域名的虚拟主机 123456vim /etc/httpd/conf/httpd.conf NameVirtualHost 192.168.31.41:80 _ip地址为虚拟机地址_&lt;VirtualHost 192.168.31.41:80&gt;DocumentRoot /var/www/tony _目标指向第三步创建的文件夹_ServerName tony.text.com _网址，如果你有的话_&lt;/VirtualHost&gt; 5. 重新开启apache服务 1systemctl restart httpd 6. 将服务设置为开机自启 1systemctl enable httpd]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
</search>
