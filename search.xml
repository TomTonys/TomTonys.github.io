<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python将图片转化ASCII]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E5%B0%86%E5%9B%BE%E5%83%8F%E8%BD%AC%E5%8C%96%E4%B8%BAasci%2F</url>
    <content type="text"><![CDATA[用Python将图片转化ASCII思路将彩图转化为灰度模式(去掉颜色)，再更具每个像素的灰度值找到不同复杂度的ASCII字符一一映射，从而转换为ASCII字符图像 环境(我的环境) 1. python3.72. Pillow库注意:Pillow库与PIL库不可存在于同一环境3. 图片 实现步骤 1. 导入Pillow库 from PIL import Image 2. 读取图片并将其转换为灰度模式(去色) 123img = Image.open("tomtony.png")img_gray = img.convert("L")img_gray.show() 3. 重置图片大小 img_gray = img_gray.resize((int(img_gray[0] * 0.5), int(img_gray[1] * 0.5)))0.5为缩放大小可随意修改 4. 根据灰度值转化为ASCII 灰度模式的图像它每个像素有一个灰度值，这个值的范围是 0 ~ 255，它的值越小说明它越黑(0是纯黑色，255是纯白色) 获取灰度值 img_gray.getpixel(100, 100)图像在100*100这个像素的灰度值 根据灰度值将图像转化为asci 1234567asciis = "@%#*+=-:. "texts = ''for row in range(height): for col in range(width): gray = img_gray.getpixel((col, row)) texts += asciis[int(gray / 255 * 9)] # 根据灰度值选择不同复杂度的 ASCII 字符 texts += '\n' 5. 最后保存为文件12with open("ascii.txt", "w") as f: f.write(texts) 最终代码12345678910111213141516171819202122232425262728293031323334353637from PIL import Imagedef get_pic_info(pic, zoom_pic): img = Image.open(pic) img_gray = img.convert('L') width, height = img_gray.size img_gray = img_gray.resize((int(width * zoom_pic), int((height * zoom_pic) * 0.5))) size = img_gray.size return size, img_graydef get_ascils(pic_info): width = pic_info[0][0] height = pic_info[0][1] img_gray = pic_info[1] ascils = '@%#*+=_. ' texts = "" for row in range(height): for col in range(width): gray = img_gray.getpixel((col, row)) texts += ascils[int(gray / 255 * 8)] texts += '\n' return textsdef save_ascil(pic_to_ascils, pic): name = ''.join(pic.split('.')[:-1]) + str('.txt') with open(name, 'w') as file: file.write(pic_to_ascils)def main(): pic = input('请放入图片:') zoom_pic = float(input('请输入缩放比例(eg:0.1):')) pic_info = get_pic_info(pic, zoom_pic) pic_to_ascils = get_ascils(pic_info) save_ascil(pic_to_ascils, pic)if __name__ == '__main__': main() 此篇blog是学习了小甲鱼的极客Python之效率革命的将你的女神变成字符画之后写的学习笔记]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多点触控 MultiAction]]></title>
    <url>%2F2018%2F10%2F21%2FMultiAction%2F</url>
    <content type="text"><![CDATA[MultiActionMultiAction是多点触控的类，可以模拟用户多点操作。主要包含add()和perform()两个方法，MultiAction可以结合前面所学的ActionTouch可以模拟出用户的多个手指滑动的效果。 12from appium.webdriver.common.multi_action import MultiActionfrom appium.webdriver.common.touch_action import TouchAction 加载:方法add(self,*touch_actions)将TouchAction对象添加到MultiAction中，稍后执行参数:touch_action 一个后多个TouchAction对象，描述一个手指要执行的动作链用法: 12345a1 = TouchAction(driver)a1.press(x,y).move_to(x,y).release()a2 = TouchAction(driver)a2.press(x,y).move_to(x,y).release()MultiAction(driver).add(a1, a2) 执行perform(self) 执行存储在对象中的操作。用法: 12345a1 = TouchAction(driver)a1.press(x,y).move_to(x,y).release()a2 = TouchAction(driver)a2.press(x,y).move_to(x,y).release()MultiAction(driver).add(a1, a2).perform() 手机缩放图示理解 实例在百度APP中执行放大两次再缩小两次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from appium import webdriverfrom appium.webdriver.common.multi_action import MultiActionfrom appium.webdriver.common.touch_action import TouchActiondesired_caps = &#123;&#125;desired_caps['platformName']='Android'desired_caps['deviceName']='127.0.0.1:62026'desired_caps['platforVersion']='5.1.1'desired_caps['app']=r'H:\测试学习\com.baidu.BaiduMap.apk'desired_caps['appPackage']='com.baidu.BaiduMap'desired_caps['appActivity']='com.baidu.baidumaps.WelcomeScreen'desired_caps['noReset']='False'driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)driver.implicitly_wait(10)driver.find_element_by_id('com.baidu.BaiduMap:id/dj2').click()driver.find_element_by_id('com.baidu.BaiduMap:id/byo').click()def get_size(): x = driver.get_window_size()['width'] y = driver.get_window_size()['height'] return x, ydef pinch(): size = get_size() x = size[0] y = size[1] action1 = TouchAction(driver) action2 = TouchAction(driver) pinch_action = MultiAction(driver) action1.press(x = x * 0.2, y = y * 0.2).wait(1000).move_to(x = x * 0.4, y = y*0.4).wait(1000).release() action2.press(x = x * 0.8, y = y * 0.8).wait(1000).move_to(x = x * 0.6, y = y*0.6).wait(1000).release() print('pinch...') pinch_action.add(action1, action2) pinch_action.perform()def zoom(): size = get_size() x = size[0] y = size[1] action1 = TouchAction(driver) action2 = TouchAction(driver) zoom_action = MultiAction(driver) action1.press(x=x * 0.4, y=y * 0.4).wait(1000).move_to(x=x * 0.2, y=y * 0.2).wait(1000).release() action2.press(x=x * 0.6, y=y * 0.6).wait(1000).move_to(x=x * 0.8, y=y * 0.8).wait(1000).release() print('zoom...') zoom_action.add(action1, action2) zoom_action.perform()if __name__ == '__main__': for i in range(2): pinch() for i in range(2): zoom()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>触控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性测试简单介绍]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。而对于浏览器软件的开发和设计，浏览器对标准的更好兼容能够给用户更好的使用体验。 --来自百度百科 什么情况下做兼容性测试用的比较少的页面(比如后台)是不需要兼容性测试的，只有大量用户用的B/S网页才需要做兼容性测试一般用什么浏览器一般必须的有：360 IE Firefox Chroem Safari，其他看公司具体要求浏览器版本一般用最新或自己电脑上的版本就可以了检查内容主要检查：功能、UI辅助工具1. https://app.crossbrowsertesting.com, 国外的一个兼容性测试网站，可以模拟主流平台和浏览器，有试用时间 2. Turbo 官网：https://turbo.net/browsers, 是一个浏览器沙盒，内置有主流的浏览器，就不用在自己的电脑上安装各种浏览器。(缺点：程序启动速度慢)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bug的等级]]></title>
    <url>%2F2018%2F10%2F18%2Fbug%E7%AD%89%E7%BA%A7%E5%88%86%E5%88%92%2F</url>
    <content type="text"><![CDATA[Bug的等级bug的等级，这个划分有分三级、四级和五级的。如果是等级越高，那么可能被修复的等级也会高一些，在一些公司bug的数量和bug的等级是考察绩效的重要标准。很多情况下，我们提交的bug大致的等级差不多即可，没有严格区分。bug的等级，一般可参照如下判断 Bug划分依据（参考）（一）致命错误： 1、常规操作引起的系统崩溃、死机、死循环。（如：输入正确的用户名密码后点击登录，机器会卡死） 2、造成数据泄漏的安全性问题。（如：恶意攻击造成的账户私密信息泄漏） 3、涉及金钱 计算（二）严重错误： 1、重要功能不能实现 2、错误的波及面广，影响到其他重要功能正常实现 3、非常规操作导致的程序崩溃、死机、死循环 4、外观难以接受的缺陷 5、密码明文显示（三）一般错误：不影响产品的运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷 1、次要功能不能实现 2、操作界面错误（包括数据窗口内列明定义、含义不一致） 3、查询错误，数据错误显示 4、简单的输入限制未放在前段进行控制（格式限制） 5、删除操作为给出提示Bug的生命周期]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>等级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例]]></title>
    <url>%2F2018%2F10%2F17%2FTestCase%2F</url>
    <content type="text"><![CDATA[测试用例测试用例的八大要素：1.用例编号产品名-测试阶段-测试项-xxx 2.测试项目对应一个功能模块(细分功能) 3.测试标题直接对测试点进行细化得出，输入内容+结果，同一功能模块标题不能重复(来自测试点) 4.重要级别高/中/低 5.预置条件需满足一些前提条件，否则用例无法执行 6.测试输入需要加工的输入信息，更具具体情况来设计(跟步骤结合起来一定要有指导意义) 7.操作步骤明确给出每个步骤的描述，执行人员可以根据该步骤完成执行工作 8.预期结果根据预期输出对比实际结果，来判断被测对象是否符合需求。(预期结果唯一，不能出现”是否或者”) 实例Excel版XMind版]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>用例设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例设计方法]]></title>
    <url>%2F2018%2F10%2F17%2FTestCaseDesignMethod%2F</url>
    <content type="text"><![CDATA[测试用例设计方法 等价类划分法等价类划分法时一种典型的、重要的黑盒测试方法，是指某个输入域的子集合。在该子集合中，所有的输入数据对于揭露软件中的储物都是等效的。等价类划分有效等价类和无效等价类 例子 边界值分析法边界值分析法时对等价类划分法的一个补充，边界值一般都是从等价的边缘值去寻找。边界值分析法的基本思想：正好等于、刚刚大于、刚刚小于边界的值作为初始数据注意：0和负数是特殊值，考虑边界值是也要考虑进入 例子在上图的条件下边界值有-1,0,1,58,59,60,61,99,100,101 错误推测法故意进行错误操作，看看有没有异常处理 例子例如测试登录功能时，用错误的账号密码进行测试 场景法从用户的角度出发，看用户怎么操作(一般用于多个功能) 例子]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>用例设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动操作 TouchAction]]></title>
    <url>%2F2018%2F10%2F16%2FTouchAction%2F</url>
    <content type="text"><![CDATA[TouchActionTouch Action包含一些列操作，比如按压、长按、点击、移动、暂停。由着些不同操作可以组成一套动作。使用TochAction需要先导入对应的模块from appium.webdriver.common.touch_action import TouchAction 按压方法：press() 开始按压一个元素或坐标点（x,y）。通过手指按压手机屏幕的某个位置。 press也可以接收屏幕的坐标（x,y）。 12press(self, el=None, x=None, y=None)TouchAction(driver).press(x=0,y=300) 长按方法：longPress() 开始按压一个元素或坐标点（x,y）。 相比press()方法，longPress()多了一个入参，既然长按，得有按的时间吧。duration以毫秒为单位。1000表示按一秒钟。其用法与press()方法相同。 long_press(self, el=None, x=None, y=None, duration=1000) 点击方法：tap() 对一个元素或控件执行点击操作。用法参考press()。 tap(self, element=None, x=None, y=None, count=1) 移动_方法：move_to() 将指针从上一个点移动到指定的元素或点。_ move_to(self, el=None, x=None, y=None) 暂停方法：Wait(),暂停脚本的执行，单位为毫秒 wait(self, ms=0) 释放方法release() 结束的行动取消屏幕上的指针。 release(self) 执行perform() 执行的操作发送到服务器的命令操作 perform(self) TouchAction实例-九宫格滑动操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from appium import webdriverfrom appium.webdriver.common.touch_action import TouchActionfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.common.exceptions import NoSuchElementExceptionfrom time import sleepdesired_caps=&#123;&#125;desired_caps['platformName']='Android'desired_caps['deviceName']='127.0.0.1:62025'desired_caps['platforVersion']='5.1.1'desired_caps['app']=r'H:\测试学习\mymoney.apk'desired_caps['appPackage']='com.mymoney'desired_caps['appActivity']='com.mymoney.biz.splash.SplashScreenActivity'driver=webdriver.Remote('http://localhost:4723/wd/hub',desired_caps)driver.implicitly_wait(5)def get_size(): x=driver.get_window_size()['width'] y=driver.get_window_size()['height'] return x,ydef swipeLeft(): l=get_size() x1=int(l[0]*0.9) y1=int(l[1]*0.5) x2=int(l[0]*0.1) driver.swipe(x1,y1,x2,y1,1000)def swipeUp(): l = get_size() x1 = int(l[0] * 0.5) y1 = int(l[1] * 0.95) y2 = int(l[1] * 0.35) driver.swipe(x1, y1, x1, y2, 1000)WebDriverWait(driver,6).until(lambda x:x.find_element_by_id('com.mymoney:id/next_btn'))for i in range(2): swipeLeft() sleep(0.5)driver.find_element_by_id('com.mymoney:id/begin_btn').click()try: closeBtn=driver.find_element_by_id('com.mymoney:id/close_iv')except NoSuchElementException: passelse: closeBtn.click()driver.find_element_by_id('com.mymoney:id/nav_setting_btn').click()WebDriverWait(driver,6).until(lambda x:x.find_element_by_id('com.mymoney:id/content_container_ly'))swipeUp()driver.find_element_by_android_uiautomator('new UiSelector().text("高级")').click()driver.find_element_by_id('com.mymoney:id/password_protected_briv').click()driver.find_element_by_id('com.mymoney:id/lock_pattern_or_not_sriv').click()for i in range(2): TouchAction(driver).press(x=218,y=298).wait(2000)\ .move_to(x=360,y=298).wait(1000)\ .move_to(x=510,y=440).wait(1000)\ .move_to(x=510,y=590).wait(1000)\ .release().perform()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>touchaction</tag>
        <tag>滑动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动]]></title>
    <url>%2F2018%2F10%2F14%2Fswipe%2F</url>
    <content type="text"><![CDATA[swipe 滑动语法 driver.swipe(x1, y1, x2, y2, 1000) 由坐标(x1,y1)滑动到坐标(x2,y2)处,持续时间1秒 坐标获取技巧_可同过get_devices_size()得到荧幕宽高后,在分别乘以一个0.X的浮点数则可得到一坐标_ 1234x = driver.get_window_size()['width']y = driver.get_window_size()['height']x1 = int(x*0.9)y1 = int(y*0.5) 具体事例由右向左滑动两次 123456789101112131415161718from appium_test.capability import driverimport timedef get_devices_size(): x = driver.get_window_size()['width'] y = driver.get_window_size()['height'] return x, ydef swipeLeft(): l = get_devices_size() x1 = int(l[0]*0.9) x2 = int(l[0]*0.1) y1 = int(l[1]*0.5) driver.swipe(x1, y1, x2, y1, 1000)for i in range(2): swipeLeft() time.sleep(0.5)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>appium</tag>
        <tag>swipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5定位方法]]></title>
    <url>%2F2018%2F10%2F14%2FH5%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[APP内嵌H5定位方法方法：定位app内元素时用appium定位方法定位,定位H5页面元素时用selenium定位方法定位.他们之间的切换用contexts切换 第一步 得到APP和H5的contexts值 12contexts = driver.contextsprint(contexts) 这里得到的第一个值为APP的contexts，第二个为selenium的contexts so 12context_appium = contexts[0]context_selenium = context[1] 第二步 appium和selenium之间的切换appium切换到selenium driver.switch_to.contexts(&#39;WEBVIEW_com.wondershare.drfone&#39;)或 driver.switch_to.contexts(context_selenium) selenium切换到appium driver.switch_to.context(&#39;NATIVE_APP&#39;)或 driver.switch_to.contexts(context_appium) 实例 1234567891011121314151617181920212223242526272829303132333435from appium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitimport timedesired_caps=&#123;&#125;desired_caps['platformName']='Android'desired_caps['platformVersion']='5.1.1'desired_caps['deviceName']='127.0.0.1:21503'desired_caps['app']=r'H:\测试学习\dr.fone3.2.0.apk'desired_caps['appPackage']='com.wondershare.drfone'desired_caps['appActivity']='com.wondershare.drfone.ui.activity.WelcomeActivity'driver=webdriver.Remote('http://localhost:4723/wd/hub',desired_caps)driver.implicitly_wait(8)time.sleep(5)driver.find_element_by_id('com.wondershare.drfone:id/btnBackup').click()WebDriverWait(driver,10).until(lambda x:x.find_element_by_id('com.wondershare.drfone:id/btnRecoverData'))driver.find_element_by_id('com.wondershare.drfone:id/btnRecoverData').click()WebDriverWait(driver,10).until(lambda x:x.find_element_by_class_name('android.webkit.WebView'))contexts=driver.contextsprint(contexts)context_selenium = contexts[1]context_appium = contexts[0]#driver.switch_to.context(context_selenium)driver.switch_to.context('WEBVIEW_com.wondershare.drfone')driver.find_element_by_id('email').send_keys('shuqing2018@163.com')driver.find_element_by_class_name('btn_send').click()#driver.switch_to.context(context_appium)driver.switch_to.context('NATIVE_APP')driver.find_element_by_class_name('android.widget.ImageButton').click()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>h5定位</tag>
        <tag>contexts</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux计划任务_crontab]]></title>
    <url>%2F2018%2F10%2F13%2FLinux%E8%AE%A1%E5%88%92_crontab%2F</url>
    <content type="text"><![CDATA[crontab常用命令创建计划任务 crontab -e 查看已创建的计划任务 crontab -l 删除计划任务 crontab -r 计划格式 * * * * * command 分 时 日 月 周 命令星号（）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如/10，如果用在minute字段，表示每十分钟执行一次。 例子 0 12,17,20 * * * python2 /home/test/test.py &gt;&gt; /home/test/test.log 每天12/17/20点整执行Python文件test.py,并将输出结果保存到test.log文件中]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ADB截图 adb shell screencap /sdcard/wangdoujia.png 安装apk adb install xxx.apk 删除APP adb uninstall xxxxxx为apk的包名 显示手机所有的APP包名 adb shell pm list package aapt查看app的package aapt dump badging H:\测试学习\wandoujia.apk | findstr “package” 查看app的启动页面的activity aapt dump badging H:\测试学习\wandoujia.apk | findstr “launchable-activity” Moneky在手机上执行100个伪随机事件 adb shell monkey 100 每次随机事件间隔3秒并显示日志 adb shell monkey -v –throttle 3000 10 自定义事件概率touch概率为30% adb shell monkey -v –pct-touch 30 200_触控touch,启动事件—appswtich,手势—motion,旋转—rotation,轨迹—trackball,基本导航—nav,主要导航-majornav,系统按键-syskeys 设定多个事件的概率 adb shell monkey -v –pct-touch 30 –pct-motion 40 200 在指定的地方执行事件在指定的app里进行随机事件 adb shell monkey -p 包名 100 在指定的activity内进行随机事件 adb shell monkey -c activity 100 遇到特殊事件处理遇到crash后继续事件 adb shell monkey –ignore-crashes 遇到超时时继续事件 adb shell monkey –ignore-timouts 遇到权限不足时继续事件 adb shell monkey –ignore-security-exceptions Moneky API启动应用的activity LaunchActivity(pkg_name,cl_name)参数：包名，启动的activity 模拟一次点击事件 Tap(x,y,tapDuration)参数：x,y坐标。tap持续时间(省) 设置睡眠时间 UserWait(sleepTime) 按键 DispatchPress(keyName) 输入字符串 DispatchString(input) 打开关闭软键盘 DispatchFlip(true/false) 长按事件 PressAndHold(x,y,pressDuration) 缩放手势 Drag(xStart,yStart,xend,yend,x2Start,y2Start,x2end,y2end,stepCount) 运行1次脚本 adb shell monkey -f /sdcard/test.txt -v -v 1脚本是用Moneky API编写的脚本,文件后缀理论不限一般为.txt,脚本需放在测试手机内 log保存 adb shell monkey 100 1&gt;d:\log.log 2&gt;d:\error.log1标准流在log.log 文件中,2错误流在error.log中 实例 adb shell monkey -p com.tal.kaoyan –pct-touch 40 –pct-motion 25 –pct-appswitch 10 –pct-rotation 5 -s 1666 –throttle 400 –ignore-crashes –ignore-timeouts -v -v 200在考研APP里以触控25%手势40%启动10%旋转5%的概率和seed为1666为条件执行200次随机事件，并且每个事件隔0.4秒执行一次，在执行中遇到crash和权限问题都跳过继续执行之后的事件]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>adb</tag>
        <tag>aapt</tag>
        <tag>Moneky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架设简单的服务器]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%9E%B6%E8%AE%BE%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在虚拟机中的Centos 7上架设搭建简单的网站1. 安装Apache服务 1yum install -y httpd 2. 启动Apache服务 1systemctl start httpd.service 3. 在“/var/www/”下创建web文件夹 1mkdir /var/www/tony 4. 更改配置文件，设置基于域名的虚拟主机 123456vim /etc/httpd/conf/httpd.conf NameVirtualHost 192.168.31.41:80 _ip地址为虚拟机地址_&lt;VirtualHost 192.168.31.41:80&gt;DocumentRoot /var/www/tony _目标指向第三步创建的文件夹_ServerName tony.text.com _网址，如果你有的话_&lt;/VirtualHost&gt; 5. 重新开启apache服务 1systemctl restart httpd 6. 将服务设置为开机自启 1systemctl enable httpd]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
</search>
